{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>PAROL6 is a high-performance 3D-printed desktop robotic arm. The design approach of PAROL6 was to be similar to industrial robots in terms of mechanical design, control software, and usability. Control software, GUI, and robots STL files are open-source. You can build your own PAROL6 robot by following the instructions located in Github respository.</p> <p>Note</p> <p>Visit our Official website and check out our other projects!</p>"},{"location":"#project-links","title":"Project links","text":"<ul> <li>Source robotics website: Link</li> <li>For building instructions visit: Link</li> <li>All project files are on Github: Link</li> <li>PAROL commander software on Github: Link</li> <li>Python API to control PAROL6 via custom python scripts, terminal or LLMs: Link</li> <li>Discord community visit: Link</li> <li>Official forum visit: Link</li> <li>See more of our robots on Youtube, Instagram, Twitter(X)</li> </ul>"},{"location":"#documentation-layout","title":"Documentation layout","text":"<pre><code>docs/\n    Home                    # Homepage of the project.\n    About PAROL6            # Robot specifications, limits and.features\n    General concepts        # General robotics concepts and theory.\n    PAROL6 control board    # All about control board and how to use it.\n    Getting started         # How to start using PAROL6 robot.\n    Software                # All about PAROL6 software and API.\n    PAROL6 commander GUI    # All about commander GUI interface\n    Peripherals             # All about grippers, pneumatics, PLCs...\n    Safety and handling     # How to not break your robot.\n</code></pre>"},{"location":"#preface","title":"Preface","text":"<p>This manual offers guidance on operating the 6-axis robot \"Parol6\" and its accompanying \"Parol6\" software. The Parol6 is a versatile robot designed for a wide audience, including educational institutions, robotics enthusiasts, and small-scale automation applications. It serves as a practical tool for learning, exploration, and implementing robotics in various fields.</p>"},{"location":"#liability","title":"Liability","text":"<ol> <li> <p>Source Robotics shall not assume liability for any accidents, damages, and/or issues resulting from the improper use of the Parol6 robot. If PAROL6 is built by users we cant guarantee that you followed the instructions for proper safety.</p> </li> <li> <p>Source Robotics retains the right to modify, revise, or update this manual, BOM and assembly instructions without prior notice.</p> </li> </ol>"},{"location":"#licence","title":"Licence","text":"<p>All code, building instructions/BOM and STL files are under GPLv3 Licence.</p>"},{"location":"page2_2/","title":"Robot specifications","text":""},{"location":"page2_2/#specs","title":"Specs","text":"<ul> <li>Payload: 1 Kg near the base, 0.5kg in whole workspace</li> <li>Weight: 5.5 Kg</li> <li>Reach: 400 mm with the standard gripper</li> <li>Degrees of freedom: 6 rotating joints</li> <li>Material: 3D printed PETG plastic</li> <li>Power consumption: 40W</li> <li>Repeatability: 0.1 mm</li> <li>Precision: </li> <li>Rotation range: </li> <li>1 \u2013 250 deg</li> <li>2 \u2013 141 deg</li> <li>3 \u2013 180 deg</li> <li>4 \u2013 212 deg</li> <li>5 \u2013 180 deg</li> <li>6 - \u221e</li> <li>Motors: Steppers</li> <li>Gearboxes: precision planetary and bets</li> <li>Position sensing: Limit switches for open loop version</li> <li>Drivers: Open-loop stepper drivers for open loop version</li> <li>Number of isolated outputs: 2</li> <li>Number of active CAN buses: 1</li> <li>Communication with master PC: USB </li> <li>Pneumatic connectors: 2</li> </ul>"},{"location":"page2_2/#operating-temperatures","title":"Operating temperatures","text":"<p>Stepper motors can work up to 100-110 degrees with no problems. In case of PAROL6 that is not acceptable since it is built out of plastic. That is why we recommend PETG because of its high glass transiton temperature.  Stepper motors will reach these temperatures after 5 hours when just holding position:</p> <ul> <li>Joint 1 - 51 \u00b0C</li> <li>Joint 2 - 54 \u00b0C</li> <li>Joint 3 - 48 \u00b0C</li> <li>Joint 4 - 60 \u00b0C</li> <li>Joint 5 - 60 \u00b0C</li> <li>Joint 6 - 61 \u00b0C</li> </ul> <p>When robot is moving it will reach these temperatures after 2 hours:</p> <ul> <li>Joint 1 -  64 \u00b0C</li> <li>Joint 2 -  64 \u00b0C</li> <li>Joint 3 -  52 \u00b0C</li> <li>Joint 4 -  73 \u00b0C</li> <li>Joint 5 -  72 \u00b0C</li> <li>Joint 6 -  65 \u00b0C</li> </ul> <p>Currents can be adjusted by adjusting values in PAROL6 control board. Values to be adjusted are located in constants.h  MOTORx_MAX_CURRENT is max stepper current.  In motor_init.cpp you can adjust: Joint__-&gt;hold_multiplier (Hold_current = MAX_current * hold_multiplier) Adjusting currents will reduce motor torque production and in turn max speeds/accels.</p> <p>Danger</p> <p>When using robot for longer periods you MUST REDUCE THE CURRENT in the software or you risk destroying your robot!</p>"},{"location":"page2_2/#dimensions","title":"Dimensions","text":"<p>Dimensions using default pneumatic gripper!</p> a1 110.50 mm a2 23.42 mm a3 180.00 mm a4 43.50 mm a5 176.35 mm a6 62.8 mm a7 45.25 mm"},{"location":"page2_2/#kinematic-diagram","title":"Kinematic diagram","text":"<p>Dimensions can change!</p> <p>For example when you change grippers or put robot on additional base.  If that happens you need to change your parameters in DH table, otherwise you kinematic diagram will be wrong  </p> <p> </p> <ul> <li>Kinematic Diagram for the robot using standard pneumatic gripper</li> </ul>"},{"location":"page2_2/#denavit-hartenberg-parameters","title":"Denavit-Hartenberg parameters","text":"<p>Standby position</p> <p>THIS IS THE POSITION OF THE ROBOT DEFINED BY THE DH TABLE BELOW! This position is also called standby positon! In this position joint angles are as follows: Joint 1 -&gt; 0 degress Joint 2 -&gt; -90 degress Joint 3 -&gt; 180 degrees Joint 4 -&gt; 0 degrees Joint 5 -&gt; 0 degrees Joint 6 -&gt; 180 degrees </p> <p> </p>"},{"location":"page2_2/#joint-reduction-ratios-and-microstepping","title":"Joint reduction ratios and microstepping","text":"<p>Reduction ratios for each joint are as follows:</p> <ul> <li>Joint 1 -&gt; Belt reduction: 6.4 : 1</li> <li>Joint 2 -&gt; Planetary gearbox: 20 : 1</li> <li>Joint 3 -&gt; Planetary gaerbox: 20 : 1 x Belt reduction 38 : 42 = 18.0952381</li> <li>Joint 4 -&gt; Belt reduction: 4 : 1</li> <li>Joint 5 -&gt; Belt reduction: 4 : 1</li> <li>Joint 6 -&gt; Planterary gearbox: 10 : 1</li> </ul> <p>Robot uses stepper motors. Microstepping is on all motors equal to 32.  With 32 microstepping regular 200 steps per revolution stepper motor needs 6400 steps for one revolution.</p> <p>Smallest theoretical steps with 32 microstep at the joint levels are   (these values are after the reduction ratios!):</p> <ul> <li>Joint 1 -&gt; 0.00015339807878856412 RAD --&gt; 0.0087890625 DEG</li> <li>Joint 2 -&gt; 4.9087385212340514e-05 RAD --&gt; 0.0028125 DEG </li> <li>Joint 3 -&gt; 5.4254478392586896e-05 RAD --&gt; 0.0031085526315789477 DEG</li> <li>Joint 4 -&gt; 0.0002454369260617026 RAD  --&gt; 0.0140625 DEG</li> <li>Joint 5 -&gt; 0.0002454369260617026 RAD  --&gt; 0.0140625 DEG</li> <li>Joint 6 -&gt; 9.817477042468103e-05 RAD  --&gt; 0.005625 DEG</li> </ul>"},{"location":"page2_2/#joint-limits","title":"Joint limits","text":"<p>TIP</p> <p>Joint limits can change depending on type of gripper or base!   When using the robot make sure you use proper joint limits for your aplicaiton!  </p> <p>Robot joint positive rotations are in the directions shown on the image!</p> <p> </p> <p>TIP</p> <p>Values are in degrees!</p> Joint Limit in negative direction Standby position Limit in positive direction J1 -123.046875 0 123.046875 J2 145.0088 -90 -3.375 J3 107.866 180 287.8675 J4 -105.46975 0 105.46975 J5 -90 0 90 J6 0 180 360"},{"location":"page3_1/","title":"PAROL6 control board","text":""},{"location":"page3_1/#introduction","title":"Introduction","text":"<p>The PAROL6 control board is the advanced 32-bit controller for 6 AXES robotic arms like PAROL6. It works out of the box with PAROL6 and PAROL6 commander software.</p> <p>To use PAROL6 robotic arm with PAROL6 commander software you will need a PAROL6 control board. The PAROL6 control board is a compact robotic controller. It is by size a little bigger than a pack of playing cards. It allows PAROL6 to be a really small and portable robot without the need for a control cabinet that is usually the size of the whole robot.</p> <p>Note</p> <p>There are two functionally identical versions of the PAROL6 control board. The version with orange spring-loaded contacts is no longer being produced. The version with a pluggable system terminal block is now in production and available in our store.</p> <p> </p>"},{"location":"page3_1/#features","title":"Features","text":""},{"location":"page3_1/#hardware-specs","title":"Hardware specs","text":"Processor STM32F446RE Processor features Arm Cortex-M4 core with DSP and FPU, 512 Kbytes of Flash memory, 180 MHz CPU, ART Accelerator Communication interfaces 2 x CAN bus (CAN2 transceiver  is not soldered), 1 x USB Stepper drivers TMC5160 Stepper drivers features SPI comms, 10-35V, 3A max, protection features Inputs 2 x ISOLATED Ouputs 2 x ISOLATED, 0.5A current output Estop input Dedicated pin on MCU for ESTOP interrupt, 2 ESTOP connections on control board Additional  memory W25Q64FV, SPI, 64Mb Programming  interface JTAG Cooling fan connection 5V cooling fan Connection for smart power button"},{"location":"page3_1/#operating-limits","title":"Operating limits","text":"Power supply 18V minimal, 24V maximal voltage Stepper drivers Rated current 2.5A, maximal current 3.6A (Short burst or extreme cooling) Temperature 100 deg stepper driver temperature warrning, 120 deg temperature error Isolated Inputs voltage 24V nominal voltage, min 12V max 50V Isolated Outputs voltage Max 48V Isolated Inputs current Isolated Outputs current Max 1A Fuse Fuse is used for outputs if used in NON ISOLATED MOD; 2A fuse Cooling fan Maximal allowed current draw for cooling fan is 0.3A"},{"location":"page3_1/#physical-properties","title":"Physical properties","text":""},{"location":"page3_1/#dimensions","title":"Dimensions","text":"<p>Note</p> <p>Dimensions are in millimeters!</p> <p> </p>"},{"location":"page3_1/#mounting","title":"Mounting","text":"<p>3 Holes located on PAROL6 control board are used to mount the PCB. Use M3 screws!</p>"},{"location":"page3_1/#cooling","title":"Cooling","text":"<p>Stepper drivers need cooling. It can be done with nocuta fan or any other 5V tolerant fan that fits the robot. In case of PAROL6 the fan needs to be of these dimensions: 40x40x20</p> <p>Keep fan current draw around 0.1 A. Do not go over 0.3 A.</p> <p>Note</p> <p>The fan cant be a PWM type fan!</p>"},{"location":"page3_1/#connections","title":"Connections","text":""},{"location":"page3_1/#connectors","title":"Connectors","text":"<ul> <li> <p>24 power connector on PAROL6 control board is XT30 MALE connector. </p> </li> <li> <p>Connector for cooling fan on PAROL6 control is  3 pin 2.54 pitch </p> </li> <li> <p>Connector for power on/off button on PAROL6 control is JST B4B-PH-SM4-TB(LF)(SN)</p> </li> <li> <p>Connector for USB on PAROL6 control is USB female type B</p> </li> <li> <p>Connector for programming adapter is 2 row x 5 pin 2.54 pitch </p> </li> </ul>"},{"location":"page3_1/#pin-definitions","title":"Pin definitions","text":"<p>TIP</p> <p>Even tho pins are named PUL1-PUL6 that does not mean they are  connected to that joint of the robot! Follow the connection plan below for  real connections! </p> <p>Connections:</p> <pre><code>    #define PUL1 PC6 ---&gt; Controls Joint 1, PULS pin of stepper driver\n    #define PUL2 PA10 --&gt; Controls Joint 5, PULS pin of stepper driver\n    #define PUL3 PC0 ---&gt; Controls Joint 6, PULS pin of stepper driver\n    #define PUL4 PC3 ---&gt; Controls Joint 4, PULS pin of stepper driver\n    #define PUL5 PC9 ---&gt; Controls Joint 3, PULS pin of stepper driver\n    #define PUL6 PC5 ---&gt; Controls Joint 2, PULS pin of stepper driver\n\n    #define DIR1 PB15 --&gt; Controls Joint 1, DIR pin of stepper driver\n    #define DIR2 PA1 ---&gt; Controls Joint 5, DIR pin of stepper driver\n    #define DIR3 PC1 ---&gt; Controls Joint 6, DIR pin of stepper driver\n    #define DIR4 PA0 ---&gt; Controls Joint 4, DIR pin of stepper driver\n    #define DIR5 PA8 ---&gt; Controls Joint 3, DIR pin of stepper driver\n    #define DIR6 PB1 ---&gt; Controls Joint 2, DIR pin of stepper driver\n\n    #define LIMIT1 PC12 ---&gt; Connected to Limit 1 on PAROL6 control board\n    #define LIMIT2 PB3  ---&gt; Connected to Limit 2 on PAROL6 control board\n    #define LIMIT3 PA15 ---&gt; Connected to Limit 3 on PAROL6 control board\n    #define LIMIT4 PD2  ---&gt; Connected to Limit 4 on PAROL6 control board\n    #define LIMIT5 PB4  ---&gt; Connected to Limit 5 on PAROL6 control board\n    #define LIMIT6 PC11 ---&gt; Connected to Limit 6 on PAROL6 control board\n\n    #define SELECT1 PC7  ---&gt; Controls Joint 1, Select pin of stepper driver\n    #define SELECT2 PA9  ---&gt; Controls Joint 5, Select pin of stepper driver\n    #define SELECT3 PC15 ---&gt; Controls Joint 6, Select pin of stepper driver\n    #define SELECT4 PC2  ---&gt; Controls Joint 4, Select pin of stepper driver\n    #define SELECT5 PC8  ---&gt; Controls Joint 3, Select pin of stepper driver\n    #define SELECT6 PC4  ---&gt; Controls Joint 2, Select pin of stepper driver\n\n    #define GLOBAL_ENABLE PA3  --&gt; Connected to ENABLE pins of all stepper drivers.\n\n    #define MISO PA6    --&gt; SPI MISO; connected to all 6 stepper drivers and flash memory\n    #define MOSI PA7    --&gt; SPI MOSI; connected to all 6 stepper drivers and flash memory\n    #define SCK PA5     --&gt; SPI SCK; connected to all 6 stepper drivers and flash memory\n    #define FLASH_SELECT PA4 --&gt; Chip select pin of the flash memory\n\n    #define LED1 PB2  --&gt; LED1 on PCB\n    #define LED2 PB10 --&gt; LED2 on PCB\n\n    #define SUPPLY_ON_OFF PC10 --&gt; Connected to power button connector, turns on/off power fet\n    #define SUPPLY_BUTTON_STATE PC14  --&gt; Connected to power button connector, reads state of the button\n\n    #define INPUT1 PB6      --&gt; Connected to IN1 pins on the side of the board\n    #define INPUT2 PB5      --&gt; Connected to IN2 pins on the side of the board\n\n    #define OUTPUT1 PC13    --&gt; Connected to OUT2 pins on the side of the board\n    #define OUTPUT2 PB7     --&gt; Connected to OUT2 pins on the side of the board\n\n    #define ESTOP PB14 --&gt; Connected to ESTOP pins on the side of the board\n\n    #define VBUS PB0   --&gt; Reads voltage of the power supply voltage\n\n    #define USB_D_PLUS  PA12 --&gt; USB pins\n    #define USB_D_MINUS PA11 --&gt; USB pins\n\n    #define CAN1TX PB9      --&gt; CAN channel 1\n    #define CAN1RX PB8      --&gt; CAN channel 1\n\n    #define CAN2TX PB13     --&gt; CAN channel 2\n    #define CAN2RX PB12     --&gt; CAN channel 2\n</code></pre>"},{"location":"page3_1/#stepper-driver","title":"Stepper driver","text":"<p>Please use stepper drivers that are listed in the BOM. In case you dont buy them from source robotics website you will need to do few modifications to them:</p> <ul> <li>Remove 2 diag pins </li> <li>Apply thermal cement to attach the heatsink (Link to cement is in the BOM)</li> </ul> <p>Danger</p> <p>ONLY USE STEP STICK THAT ARE SPECIFIED IN THE BOM! Failing to do so will destroy your PAROL6 control board!</p> <p>Warrning</p> <p>YOU NEED TO SECURE HEATSINK TO STEPPER DRIVER WITH TERMAL CEMENT! Failing to do so will destroy your PAROL6 control board!</p>"},{"location":"page3_1/#stepper-driver-orientation","title":"Stepper driver orientation","text":"<p>Stepper drivers need to be placed with respect to this diagram to the PAROL6 control board! Stepper drivers orientation can be recognised by 2 diagnostic pins!</p> <p>Warrning</p> <p>Some stepper drivers have diag pins soldered. If they are soldered you NEED to remove them! If diag pins are on the PCB they are blocked by the capacitors on PAROL6 PCB, and you cant place the modules in. </p> <p> </p> <p>Info</p> <p>If you find a fitting TMC5160 driver make sure that it follows the pinout from the image above. </p> <p>Info</p> <p>DIAG PINS SHOULD FOLLOW RED ARROWS ON THE IMAGE BELLOW!!</p> <p> </p>"},{"location":"page3_1/#how-to-upload-code","title":"How to upload code","text":"<p>Microcontroller on PAROL6 control board is STM32F446RE. To upload code you need to use STlink device and connect it dedicated CLK, SWDIO, 3V3 and GND pins. You can use jumper cables or dedicated stlink + cable assembly.</p> <p>Danger</p> <p>Only use one of those 2 methods to program PAROL6 control board! Connecting STlink with a cable wihout adapter WILL KILL YOUR BOARD!</p>"},{"location":"page3_1/#wiring-parol6-control-board","title":"Wiring PAROL6 control board","text":"<p>You need to follow this diagram to wire your PAROL6 robot arm to PAROL6 control board.</p> <p> </p> <p>After sucesssful wiring of the robot and control board it should look somthing like this. </p> <p>Limit switches to 24V and signal. Inductive sensors to 24V, GND and signal.</p> <p> </p> <p> </p>"},{"location":"page3_1/#code-upload","title":"Code upload","text":"<p>If you are having problems with code upload via Stlink try installing the drivers: https://www.st.com/en/development-tools/stsw-link009.html</p>"},{"location":"page3_1/#pcb-revision-history","title":"PCB revision history","text":"<p>Latest version of PAROL6 PCB is: V2.0</p> <p> </p> <p>Version of PAROL6 PCB is: V1.2 that is no longer produced. This version used spring loaded phoenix contacts and is functionally the same as the latest version. </p> <p> </p>"},{"location":"page3_2/","title":"Getting started","text":""},{"location":"page3_2/#assembly-manual","title":"Assembly manual","text":"<p>Assembly manual is located in Github repository.  - If you decide to build it or buy a kit you will need to follow the assembly manual to make it.   - Assembly manual is also great tool for reparing and upgrading your robot. Make sure you use the latest version of the manual. </p> <p>After you have built the robot follow these steps to get it up and running!</p>"},{"location":"page3_2/#bom","title":"BOM","text":"<p>If you are building the robot yourself source the parts from the BOM on this link!</p>"},{"location":"page3_2/#video-guides","title":"Video guides","text":"<p>You can also follow a video tutorial to assemble and setup the robot.</p>"},{"location":"page3_2/#how-to-follow-this-guide","title":"How to follow this guide","text":"<p>It is best to read the whole guide and then go step by step on each step. If you do something wrong you will have to go a few steps back so it is recommended to read or skim through this page.</p>"},{"location":"page3_2/#do-not-do-this","title":"Do not do this","text":"<p>There are few things you should never do to your PAROL6.</p> <p>Warning</p> <p>Never spin joint 5 more then one rotation</p> <p> </p> <p>The image above represents the range of J5.</p> <p>Warning</p> <p>If you dont have blockers on joint 1 there is possibility to spin it more then 1 rotation. Never do it!</p> <p>Warning</p> <p>Robot does not have brakes. When you power off your robot steppers will stop producting torque and ROBOT WILL FALL!  Never turn off the robot without you holding it!</p>"},{"location":"page3_2/#ssg48-gripper","title":"SSG48 gripper","text":"<p>If you plan to use SSG48 gripper first make sure that your PAROL6 works and than attach it to the robot! Check the section in Peripherals on how to connect the gripper!</p>"},{"location":"page3_2/#powering-on","title":"Powering on","text":"<p>PAROL6 requires 3 connections for normal operation.</p> <ul> <li> <p>Power connection -&gt; Marked green on image</p> </li> <li> <p>USB connection -&gt; Marked blue on image</p> </li> <li> <p>ESTOP -&gt; Marked with yellow and pink squares (One lead of ESTOP goes to yellow one to pink)</p> </li> </ul> <p>If you upladed main software to the PAROL6 control board its on/off operation will work like this:  First connect power cable (marked green). After that you can turn robot on and off by pressing power button (marked red). After you press the power button the robots joints will start producing torque. You will hear 6 clicking sounds, that is normal. Robot is now locked and it is waiting to receive commands.</p> <p>Warning</p> <p>Robot will power on by itself if you have connected 3v3 supply from the programming port.</p>"},{"location":"page3_2/#stepper-induced-voltage","title":"Stepper Induced voltage","text":"<p>DO NOT SPIN UNPOWERED ROBOT WHEN CONNECTED TO SUPPLY</p> <p>Because stepper motors create voltage when spun, they can turn the robot on if you spin them. After you turn off the robot move it to standby position slowly Never randomly spin the robot when connected to power or you risk powering it on</p>"},{"location":"page3_2/#powering-off","title":"Powering off","text":"<p>Do not try to power off the robot when it is running!</p> <p>If robot starts to behave unexpectedly USE ESTOP If ESTOP is not functional power of the supply Reaching for the power button should be the last option</p> <p>Because lack of brakes sudden loss of power will result in robot falling down. That may cause damage to the robot or the operator. Robot is powered on and off by pressing a button marked red on the image. When powering the robot on even when USB connection is not available it will energise the the motors. It will produce 6 clicking sounds and that is normal behaviour.</p> <p>Powering off the robot is also done by pressing button marked in RED. Before you power off the robot GRAB IT BY THE FOREARM and then press the button. This will ensure that robot does not fall down. THESE STEPS ARE MANDATORY Failing to do so will damage your robot!</p> <p>Warning</p> <p>You will not be able to power off the robot if there is external 3v3 (from the stlink for example)</p>"},{"location":"page3_2/#installing-parol6-commander-software","title":"Installing PAROL6 commander software","text":"<p>Commander software can be located in Github repository.  Install instructions are located there.</p> <p>Using requirements.txt  CD into commander software folder  pip install -r requirements.txt </p> <p>Windows</p> <p>Linux</p> <p>More info how to install can be found in the github folder.</p>"},{"location":"page3_2/#uploading-parol6-control-board-code","title":"Uploading PAROL6 control board code","text":"<p>Microcontroller on PAROL6 control board is STM32F446RE. To upload code you need to use STlink device and connect its dedicated CLK, SWDIO, 3V3 and GND pins (Do not connect any other pin!). You can use jumper cables or dedicated stlink + cable assembly.</p> <p>Danger</p> <p>Only use one of those 2 methods to program PAROL6 control board! Connecting STlink with a cable wihout adapter WILL KILL YOUR BOARD!</p>"},{"location":"page3_2/#uploading-main-control-board-code","title":"Uploading main control board code","text":"<p>PAROL6 control boards are shipped fully tested with TEST code uploaded. You can use that test code to see if you connected your robot correctly to the control board. Main control board code is not the testing code. This code will be able to communicate with commander software. You will need to have working commander software to use this code or build your own API. </p> <p>Upload the following code Link</p> <p>If you are having problems with code upload via Stlink try installing the drivers: https://www.st.com/en/development-tools/stsw-link009.html</p> <p>If using SSG48 gripper</p> <p>In the main.cpp file change j5_homing_offset to be equal to 8035 </p>"},{"location":"page3_2/#parol6-control-board","title":"PAROL6 control board","text":"<p>Warning</p> <p>When uploading code with stlink to the robot DISCONNECT THE 24V supply from the robot. After the code is uploaded disconnect the stlink and connect power supply. </p> <p>Look at the PAROL6 control board page for more info.</p>"},{"location":"page3_2/#first-startup","title":"First startup","text":"<p>When first starting the robot (with main code uploaded) biggest and most common problem is that motors will turn in different directions from those they were supposed to move. There are 2 ways to fix this: </p> <ul> <li>Open the robot base and replace wires of one of the stepper motor phases </li> <li>RECOMMENDED-&gt; Upload a new code to PAROL6 control board with small changes to the code</li> </ul> <p>If you are going with code edit solution you will need to edit these segments of code:</p> <pre><code>    file name: motor_init.cpp\n    If rotating in wrong direction switch from 0 to 1 or 1 to 0\n    The variable to change is:\n\n\n    Joint__-&gt;direction_reversed = 1;\n</code></pre>"},{"location":"page3_2/#homing","title":"Homing","text":"<p>Homing is a process where a robot joint finds a known position in its rotation space, typically by hitting a limit switch or sensor.</p> <p>The process for PAROL6 and FAZE4 robots is the same as that for 3D printers. After powering up, the robot doesn't know its position and needs to be homed. By hitting a limit switch, we determine the robot joint's position based on our knowledge of the limit switch's location, which we have from the CAD model. For example, when we hit a limit switch on Joint 1, we know that we need x steps to reach a witness mark or Joint 1's 0-degree position.</p> <p>Now that we know our position after homing and the number of steps required from the limit switch to the witness mark, you might think we're done, right? Well, not quite. To be really precise, after hitting the limit switch, you should observe how many steps it actually takes from the limit switch to the witness mark. Each PAROL6 build may have slight differences due to various printers, tolerance variations, and parts.</p> <p>The Parol6 control board comes preloaded with generic parameters that will work for anyone building the robot. However, if you want to fine-tune your robot, you now have the option to do so.</p> <p>By default PAROL6 homes in these steps:</p> <ul> <li>Joint 1,2 and 3 move to the limit switch at the same time</li> <li>Once all are pressed they move away from them and press again.</li> <li>Now joints 1,2 and 3 move to standby position</li> <li>Now joint 4 homes</li> <li>After joint 4 is homed it moves to its standby position</li> <li>Now Joint6 homes</li> <li>After it homes it goes to positon to home joint 5</li> <li>After joint5 homes joints 5 and 6 move to the standby position</li> </ul> <p>Homing needs to look like shown in this video!</p> <p>Joints 1,4 and 6 home with inductive sensors make sure they trigger! If they do not trigger the LEDS on the sensors will not light up. To fix that you will need to adjust the screw that homes that joint</p> <p>Warning</p> <p>Joints 1,4 and 6 home with inductive sensors make sure they trigger! Failing to adjust their trigger points you risk damaging the robot!</p> <p>Note</p> <p>When starting homing procedure Joint 6 will rotate in the NEGATIVE DIRECTION TO FIND THE HOMING PIN! Make sure that it does not make to much rotations or you risk wires/tubes getting tangled and braking/damaging your robot! </p> <p> </p> <p>You will need to place the gripper in the position like this. Note that J6 wil rotate in the direction of green arrow during homing. The red circle is location of homing pin and blue arrow indicated the location of the sensor.</p> <p>Note</p> <p>If using custom gripper make sure it has a spot that can trigger joint 5 limit switch! </p>"},{"location":"page3_2/#testing","title":"Testing","text":"<p>To test PAROL6 control board connection to your robot you can use stock software or use testing software. Testing software is more safe and interactive for users. It can be found at: Link</p> <p>It is recommended to use testing code to test your components (for example test if Joint1 motor is spinning or does J3 limit switch works). </p> <p>Danger</p> <p>Using testing code on assembled robot may cause damage, only use it to test individual components and functions! </p> <p>Note</p> <p>This code will try to spin all the motors, so it is not safe to just upload it to your robot. </p> <p>Upload the code with only usb connected and Programming adapter. Programming adapter will supply your board with 3v3 and if you configure your COM port you should be able to talk to your board. It will report errors for the stepper drivers since they need 24V to power on.</p> <p>After you comfirmed that you can communicate; disconnect programming adapter and plug in 24V. Board will stay turned off until you do one of the 2 things:</p> <ul> <li>Turn the board by supplying 3v3 from the programming adapter.</li> <li>Attach power button. You will need to hold it pressed to keep the board powered.</li> </ul>"},{"location":"page3_2/#parol6-control-board-testing-software","title":"PAROL6 control board testing software","text":"<p>The code will try to communicate with stepper drivers. Output1 and Output will go from high to low every 1s and LED1 and LED2 will flash. If everything is ok you will get output like this on serial:</p> <p> </p> <p>If stepper driver is faulty or not connected you will get:</p> <p> </p> <p>If stepper drivers are good your stepper motors should spin at a low speed using moderate current of 200-300 mA.</p>"},{"location":"page3_2/#limit-test","title":"LIMIT test","text":"<p>In serial terminal write # LIMIT and press enter. You should get a output like this if you activate the switch. For  limit switches orientation is also not important (one lead to 24V other to signal. For Inductive sensors: Black - signal, Blue - negative, Brown - positive</p> <p> </p>"},{"location":"page3_2/#io","title":"IO","text":"<p>In serial terminal write # IO and press enter. You should get a output like this:</p> <p> </p> <p>If you change the state of ESTOP, INPUT1 or INPUT2 you will see states changing. You will also be able to see voltage of your power supply in mV!</p>"},{"location":"page3_2/#quick-start-guide","title":"Quick start guide","text":"<ul> <li>Attach the robot to table or workstation.</li> <li>Make sure you have PAROL6 control board that has main firmware on it!</li> <li>Connect power supply and USB to your robot.</li> <li>Test if you can move your robots joints freely.</li> <li>Turn on your power supply. IT NEEDS TO BE 24V</li> <li>Press the power button. Power button locks all the joints to the current position.</li> <li>After power button is pressed you can turn on commander software.</li> <li>Commander software has a menu at the bottom that allows you to select COM port if it is not correct in the source code</li> <li>If that option fails adjust your COM port in the commander code manually</li> <li>If you fail to connect check your COM port number again. If using linux use: sudo chmod 666 /dev/ttyACMx mutiple times</li> <li>After the commander software started you will see 2 windows: Simulator window and GUI window</li> <li>Simulator will not be calibrated to the robot and GUI will display wrong joint and cartesian coordinates.</li> <li>Go to joint jog menu and try to jog the motors.</li> <li>Arrows (OF THE JOG MENU) pointing to the left represent POSITIVE rotation of the joint and arrows pointing to the right NEGATIVE.</li> <li>Positive and negative rotations of the joints are shown on the image below</li> </ul> <ul> <li>Comfirm that every joint moves coresponding joint in right direction. If not follow first startup guide to callibrate them and only then return here.</li> <li>Once you adjusted your joint rotations repeat all the previous steps and confirm correct rotations.</li> <li>Press the home button. All joints of the robot will start to move. Be close to the estop of the robot. If you hear grinding noise when robot is close to the limit switch press the estop emediately.  That means your estop for that joint is not working and you need to check your wiring. If you see that J6 is spinning mutiple times press ESTOP and adjust your inductive sensor trigger screw.</li> <li>If the robot homes correctly it will be in position as in the image above but J1 will be rotated for +90 degree. Small deviations are ok since your robot is still not mastered. </li> <li>Simulator is now synchronized to the robot and GUI shows correct values.</li> <li>Congrats you have a functional PAROL6 robot to work with!</li> </ul>"},{"location":"page3_2/#output-log","title":"Output log","text":"<p>In your terminal you will periodically see this data:</p> <pre><code>    ROBOT DATA:\n    Position from robot is: [154, 0, 0, 0, 0, 0]\n    Speed from robot is: [0, 0, 0, 0, 0, 0]\n    Robot homed status is: [0, 0, 0, 0, 0, 0, 1, 1]\n    Robot Input/Output status is: [0, 0, 0, 0, 1, 1, 1, 1]\n    Robot temperature error status is: [0, 0, 0, 0, 0, 0, 1, 1]\n    Robot temperature error status is: [0, 0, 0, 0, 0, 0, 1, 1]\n    Timeout_error is: 100\n    Time between 2 commands raw is: 7129\n    Time between 2 commands in ms is: 0.010139022206380001\n    XTR_DATA byte is: 255\n    Gripper ID is: 255\n    Gripper position is: -100\n    Gripper speed is: 2000\n    Gripper current is: -3000\n    Gripper status is: 123\n    Gripper object detection is: 69\n\n    COMMANDED DATA:\n    Robot Input/Output status is (OUT): [0, 0, 0, 0, 0, 0, 0, 0]\n    Robot Commands is:  255\n    Commanded robot speeds are: [0, 0, 0, 0, 0, 0]\n\n    GUI DATA:\n    Joint jog buttons: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    Cart jog buttons: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    Home button state:0\n    Enable button state:0\n    Disable button state:0\n    Clear error button state:0\n    Real robot state: 1\n    Simulator robot state: 1\n    Speed slider is: 50\n    WRF/TRF is: 0\n    Demo app button state: 0\n    Shared string is: b'Log: Joint  1  jog  '\n    Program execution variable: 0\n    [255, 255, 255]\n    b'\\xff\\xff\\xff'\n    [0, 1, 1, 1, 1, 0, 1, 1]\n    b'\\x00\\xfcj\\x03'\n    0x0\n    0xfc\n    0x6a\n    b'\\x00'\n    b'\\xfc'\n    b'j'\n    fuesd\n    -235005\n    b'{'\n    $$$$$$$$$$$$$$$$\n</code></pre> <p>This data tells you about the state of the GUI and the robot. What we are interested is the value of Time between 2 commands in ms. This variable needs to be in range of 0.010 s. Monitor it for a few minutes while you jog the robot. If it is in the range of 0.01 your PC can handle the commander software. If it is not in the range your PC is probably too week.</p>"},{"location":"page3_2/#mastering-the-robot","title":"Mastering the robot","text":""},{"location":"page3_2/#witness-marks","title":"Witness marks","text":"<p>In the context of robot arms, \"witness marks\" typically refer to marks or indicators that are used to verify or witness the alignment, position, or movement of components or parts within the robotic system. These marks can serve various purposes in robot arms and automation; but are usually used to master the robot.</p> <p>Witness marks can be used during the calibration process to ensure that different components are properly aligned or positioned as per the specified configuration.</p> <p>Parol6, Faze4, and CM6 robotic arms also have witness marks. These marks are indicated by holes in the mechanical parts, allowing the parts to be aligned by inserting a pin through those holes.</p> <p> </p> <pre><code>                    Figure: Witness marks of PAROL6 robot\n</code></pre>"},{"location":"page3_2/#robot-mastering","title":"Robot mastering","text":"<p>Mastering the robotic arm is the process of bringing your robots joints to the witness mark of that joint and recording the position that robot is at that point.</p> <p>When at the position of the witness mark robots position is know because of our knowledge of robots kinematics and CAD. it basically assigns robots encoder ticks / stepper ticks to the know joint angle</p> <p>Lets take an example of J1 of our PAROL6 robotic arm</p> <p> </p> <pre><code>                    Figure: Standby position of PAROL6 robotic arm\n</code></pre> <p>At this exact position our robots joint is at 0 degrees / 0 steps. If everything was perfect you would place a pin at the witness marks and it would fit with no problems. </p> <pre><code>In the code you can edit homed_position to adjuct your robot mastering\n/// @brief how much steeps need to be made from when limit is hit to standby position\nfloat homed_position\n</code></pre>"},{"location":"page3_2/#maintenance","title":"Maintenance","text":""},{"location":"page3_2/#belts","title":"Belts","text":"<p>We recommend to periodically check your belt tension and apply greese to the belts. If you see that the belt is not tight enough place another tension bearing as shown in the pictures. </p> <p>Belts are located on Joints: 1,3,4,5</p>"},{"location":"page3_2/#joint-5-belt","title":"Joint 5 belt","text":""},{"location":"page3_2/#joint-4-belt","title":"Joint 4 belt","text":""},{"location":"page3_2/#joint-3-belt","title":"Joint 3 belt","text":""},{"location":"page3_2/#joint-1-belt","title":"Joint 1 belt","text":"<p>Use This video as a reference for belt tension! In the video we apply max force we can with the hands to the belt. You can use the belts \"stretching\" as a reference for your belt. Belts for J1 and J4 need to have a bit less tension on them.</p>"},{"location":"page3_2/#couplers-and-threadlocker","title":"Couplers and threadlocker","text":"<p>In case your joint starts to slip your set screw probably slipped. Tighten them again and make sure you use blue threadlocker. To be safe after you apply do not touch the robot for 24h. Also make sure you place screws in the keyhole! Threadlocker should be applied to all metal mating surfaces. Due the vibrations these parts will get lose screws.</p>"},{"location":"page4/","title":"Software","text":"<p>To operate PAROL6 robot you need a:</p> <ul> <li>High level software running on your PC</li> <li>Low level software running on PAROL6 control board</li> </ul> <p>For high level software there are multiple options:</p> <ul> <li>Use PAROL6 commander software for control, programming, simulating</li> <li>Use our API to send command thru your languange of choice Matlab, python, c++</li> <li>Use ROS</li> </ul> <p>For low level software only PAROL6 control board software is available.  PAROL6 commander software allows you to write simple robot arm scripts. Scripting language is called RBTscript.</p>"},{"location":"page4/#python-api","title":"Python API","text":"<p>Commander alternative</p> <p>Alternative to the commander software is controling the robot with python API. More info and guide can be found in the github repo: Link </p>"},{"location":"page4/#parol6-commander-software","title":"PAROL6 commander software","text":"<p>Commander software can be found here: https://github.com/PCrnjak/PAROL-commander-software PAROL6 commander software was writen in python. Its main purpase is to offer an interactive GUI for users to use to control and program PAROL6 robot. </p> <p>Some of the features that PAROL6 commander software has:</p> <ul> <li>Built in robot simulator </li> <li>Built in programming language RBTscript</li> <li>Control loops of up to 100Hz</li> <li>Robot jog in joint and cartesian space</li> <li>Input and Output control</li> <li>View of robot telemetry data </li> <li>Estop and safety functions</li> </ul>"},{"location":"page4/#structure","title":"Structure","text":""},{"location":"page4/#dependancy","title":"Dependancy","text":"<p>Latest stable version uses python 3.11.0 and following dependencies:</p> <ul> <li>Check dependancy here: https://github.com/PCrnjak/PAROL-commander-software</li> </ul>"},{"location":"page4/#how-to-run-install","title":"How to run / Install","text":"<ul> <li>First install proper python version</li> <li>Install all dependencies</li> <li>clone or download https://github.com/PCrnjak/PAROL-commander-software</li> <li>Run the Serial_sender_good_latest.py</li> </ul>"},{"location":"page4/#parol6-control-board-software","title":"PAROL6 control board software","text":"<p>We recommend using VS Code and platformio to install, edit and run the  code. </p>"},{"location":"page4/#parol6-control-board-software-install-guide","title":"PAROL6 control board software Install guide","text":"<ul> <li>Insall VS Code: https://code.visualstudio.com/</li> <li>In the VS Code extensions install Platformio</li> <li>Clone https://github.com/PCrnjak/PAROL6-Desktop-robot-arm or download zip folder</li> <li>In VS Code click open folder and select \"PAROL control board\" from previously downloaded folder</li> <li>Now Platformio should download all necesarry configurations to allow you to compile and upload code</li> </ul>"},{"location":"page4/#code-upload-to-parol6-control-board-software","title":"Code upload to PAROL6 control board software","text":"<p>To upload code on your PAROL6 board you need a programming cable and stlink device If you followed the steps from \"PAROL6 control board software Install guide\" you should be able to upload code to your PAROL6 PCB from VS Code.</p> <p>Programming adapter needs to be connected to the black connector next to the USB. Needed connections are 3v3, gnd, swdio, clk.</p>"},{"location":"page4/#how-to-test-parol6-control-board","title":"How to test PAROL6 control board?","text":"<p>To test PAROL6 control board special testing software was made. You can find it at: https://github.com/PCrnjak/PAROL6-Desktop-robot-arm in TESTING folder.</p> <p>This code will allow you to control idividual functions of PAROL6 robot arm (if wired as per wiring instructions).</p>"},{"location":"page4/#communication-protocol","title":"Communication protocol","text":"<p>Communication is based on UART and is being done over USB cable from the robot to the PC. The usual baud rate is 3Mbit. Data is sent to the robot at 100Hz (If your PC is not good enough this can be decrease but performance will suffer). Data is sent in specially packed compact data packets. </p> <p> </p> <pre><code>    Figure: Data packets in table format. As you can see both packets combined have less then 120 bytes. \n    With transmission speed of 3Mbit it takes 0.3 ms for a whole round trip of data!\n</code></pre> <p>Robot needs to receive valid data packet in the format defined above.  Pseudo code of how it works on PAROL6 control board:</p> <pre><code>While(1){\n\n    Perform tasks\n\n    While (Serial data available){\n        * input byte = read serial data, This reads one byte from the buffer\n        * First condition is that 3 start bytes are correct.\n        * Once Len byte is received we know how many bytes we need to get.\n        * After we get that number of bytes we check end bytes and CRC.\n        * After that we proces the data, unpack it and save in corensponding variables.\n        * After that we pack the robots telemetry data we will need to send to the PC\n\n    }\n\n}\n</code></pre> <p>So if a robot receives good data packet, meaning good first 3 bytes, len, CRC and end bytes we can start to proces the data. That signals start of one robot loop cycle.</p> <p>Duty of PC (or any other device you wish to use to control your PAROL6) is to send data at sufficiently fast loop times. Time between 2 last commands is returned by PAROL6 control board in variable Timing data.   Timing data is variable that is 2 bytes long. </p> <ul> <li>Freq is 90Mhz, with 128 prescale we get 703125, timer is 16bit</li> <li>It counts to 65535. 1 Tick is then equal to 1/703125 = 1.422222e-6</li> <li>To get 10 ms we need 7031 ticks</li> </ul> <p>By viewing that variable you can check if your loop times are correct.</p>"},{"location":"page4/#pc-robot","title":"PC -&gt; robot","text":"<p>The protocol from PC -&gt; robot consists of three types of commands:</p> <ul> <li>Active </li> <li>Passive </li> <li>Carrier </li> </ul> <p>The protocol from robot - PC consists only of robots telemetery data.</p>"},{"location":"page4/#list-of-active-commands","title":"List of active commands","text":"<p>Active commands can only be given by the \"command\" argument and is represented by one byte. That means there can only be 255 possible  commands.</p> <pre><code>0X123 - JOG\n0x156 - Go 2 positon with speed\n0X100 - Home command\n0x101 - Enable robot\n0x102 - Disable robot\n0x103 - Clear error\n0x255 - Dummy data\n</code></pre>"},{"location":"page4/#passive-commands","title":"Passive commands","text":"<p>Passive commands are for example io commands and gripper commands. They are always sent with the data packet. Passive commands do not affect movement of the robot joints and by that can be injected in any active command. </p>"},{"location":"page4/#carrier-commands","title":"Carrier commands","text":"<p>Carrrier commands are joint speeds and positions that are modifiers for active movement commands. </p>"},{"location":"page4/#robot-input-packet-pc-robot","title":"Robot input packet (PC -&gt; robot)","text":"<pre><code>uint8_t start_bytes[] = {0xff, 0xff, 0xff};         // 3 byte\nint len = 52;                                       // 1 byte\nint Joints[6];                                      // each joint is 3 bytes; total of 18 bytes\nint Speed[6];                                       // each joint is 3 bytes; total of 18 bytes\nint Command = 255;                                  // 1 byte\nint Affected_joint[] = {1, 1, 1, 1, 1, 1, 1, 1};    // 1 byte\nint InOut[] = {1, 1, 1, 1, 1, 1, 1, 1};             // 1 byte\nint Timeout;                                        // 1 byte\nint Gripper_position;                               // 2 byte\nint Gripper_speed;                                  // 2 byte\nint Gripper_current;                                // 2 byte\nint Gripper_command;                                // 1 byte\nint Gripper_mode;                                   // 1 byte\nint Gripper_ID = 212;                               // 1 byte\nint CRC_byte = 212;                                 // 1 byte\nint end_bytes[] = {0x01, 0x02};                     // 2 byte\n</code></pre>"},{"location":"page4/#robot-output-packet-robot-pc","title":"Robot output packet (ROBOT -&gt; PC)","text":"<p>Data sent from the robot to the PC consists only of robots telemetry data and flags.</p> <pre><code>uint8_t start_bytes[] = {0xff, 0xff, 0xff};             // 3 byte\nint len = 56;                                           // 1 byte\nint Position_out[] = {255, 254, 253, 252, 251, 250};    // each joint is 3 bytes; total of 18 bytes\nint Speed_out[] = {245, 244, 243, 242, 241, 240};       // each joint is 3 bytes; total of 18 bytes\nbool Homed[] = {1, 1, 1, 1, 1, 1, 1, 1};                // 1 byte\nbool IO_var[] = {0, 0, 0, 0, 0, 0, 0, 0};               // 1 byte\nbool temp_error[] = {1, 1, 1, 1, 1, 1, 1, 1};           // 1 byte\nbool position_error[] = {0, 0, 0, 0, 0, 0, 0, 0};       // 1 byte\nint timing_data = 255;                                  // 2 byte\nint timeout_error = 244;                                // 1 byte\nint xtr2 = 255;                                         // 1 byte\nint gripper_ID = 200;                                   // 1 byte\nint gripper_position = 300;                             // 2 byte\nint gripper_speed = 300;                                // 2 byte\nint gripper_current = 300;                              // 2 byte\nint gripper_status = 200;                               // 1 byte\nint object_detection = 1;                               // 1 byte\nint CRC_byte = 212;                                     // 1 byte\nint end_bytes[] = {0x01, 0x02};                         // 2 byte\n</code></pre>"},{"location":"page4/#parol6-commander-software_1","title":"PAROL6 commander software","text":""},{"location":"page4/#structure_1","title":"Structure","text":""},{"location":"page4/#how-to-run-install_1","title":"How to run / Install","text":"<p>Check here: https://github.com/PCrnjak/PAROL-commander-software</p>"},{"location":"page4/#parol6-control-board-software_1","title":"PAROL6 control board software","text":"<p>Structure of the code:</p>"},{"location":"page4/#parol6-control-board-software-api","title":"PAROL6 control board software API","text":""},{"location":"page4/#code-upload-to-parol6-control-board-software_1","title":"Code upload to PAROL6 control board software","text":"<p>To upload code on your PAROL6 board you need a programming cable and stlink device</p>"},{"location":"page4/#python-api_1","title":"Python API","text":"<p>Python API to control PAROL6 via custom python scripts, terminal or LLMs: Link</p>"},{"location":"page4/#rbtscript","title":"RBTscript","text":"<p>PAROL6 commander software allows you to write simple robot arm scripts. Scripting language is called RBTscript. It allows you to move the robot in joint space or cartesian space, use delay functions, control outputs and grippers, read inputs and much more!</p>"},{"location":"page4/#introduction","title":"Introduction","text":"<p>Commands are executed sequentally. they have tact of loop time!</p>"},{"location":"page4/#units-used","title":"Units used","text":"<p>There is a lot of conversion of units in robotics and PAROL6 is not an exception to that. To keep things simple and accurate we compiled where these conversions happen, why and how.</p>"},{"location":"page4/#angle","title":"Angle","text":"<p>Units for angles used in PAROL6 commander software are DEGREES. What we are sending PAROL6 control board are STEPS. For all calculations used in PAROL6 commander software RADIANS are used.</p>"},{"location":"page4/#distance","title":"Distance","text":"<p>Units for distance used in PAROL6 commander software are milimeter [mm]. In the backend meters are used for all caculations</p>"},{"location":"page4/#speed","title":"Speed","text":"<p>In the GUI speeds setpoints can only be set using %. Units of speed used in PAROL6 commander software backend are either STEPS/s , RAD/s or DEG/s for rotations or mm/s or m/s for translations. </p>"},{"location":"page4/#acceleration","title":"Acceleration","text":"<p>In the GUI acceleration setpoints can only be set using %.  Units of acceleration used in PAROL6 commander software backend are either STEPS/ss , RAD/ss or DEG/ss for rotations or mm/ss or m/s*s for translations. In the GUI acceleration setpoints can only be set using %.</p>"},{"location":"page4/#how-to-write-code","title":"How to write code!","text":""},{"location":"page4/#how-are-trajectories-generated","title":"How are trajectories generated?","text":""},{"location":"page4/#how-are-they-tracked","title":"How are they tracked?","text":"<p>There are 2 ways we can command robots trajectory: For example we want joint 6 to move from 260 deg to 180 degree. We want to follow trap velocity profile and get to 260 position in 2 seconds. We generated speed and position curves.  Now if we command only the speed curve robot will follow it perfectly but if the move is too long or too fast it will miss the demanded  positon. Why? We are sending commands every 10 ms. but it is not always exactly 10 ms since your PC is not real time machine. Another thing is that steppers cant execute some really small speed moves from the begging and the ends of the speed curve. Because of that positon is missed usually.  How to compensate that? Using the  position curve! Using current positon and commadned positon we calculate how fast you need to go. After that take that speed and add commanded speed from the speed curve and average that. This gives the results you can see in the plots below. In commands MoveJoint, MovePose, MoveCart and MoveCartRelTRF following only with speed or speed + positon can be selected by \"speed\" argument.</p> <p> </p> <pre><code>      Figure: Trapezoidal velocity profile. BLUE is commanded velocity profile and RED is actual robot speed. \n       These diagrams are for mode where both positon and speed are commanded and avg was taken. Green lines \n       show that robot is 1/3 of the path in acceleration 1/3 in cruise and 1/3 in deceleration.\n</code></pre> <p> </p> <pre><code>        Figure: Positon curve when following only with speed vs speed + positon.  \n        You can see they are both really close but with speed and positon robot comes to  \n        exactly the commanded positon. This plot is for trapezoidal velocity profile.\n</code></pre> <p> </p> <pre><code>        Figure: This is same commanded positon but with polynomial. \n         As you can see same applies as for trapezoidal\n</code></pre>"},{"location":"page4/#functions","title":"Functions","text":""},{"location":"page4/#movejointj1j2j3j4j5j6v0a0t0funcspeed","title":"MoveJoint(j1,j2,j3,j4,j5,j6,v=0,a=0,t=0,func,speed)","text":"<p>Robot will move all its joints to the desired positons tracking a specific velocity curve. Joints will stop at the same time at the desired positons. The path is linear in joint space, because of that actuator motion is easy to validate and predict but TRF/end-effector is hard to predict. Can track trapezoidal velocity profile or polynomial veloctiy profile. User can set desired duration of the move or specific acceleration and velocity.  The move can be tracked based on speed curve alone or combination of commanded speed curve and position curve.</p> <ul> <li>j1,j2,j3,j4,j5,j6 -&gt; desired joint values [degrees] REQUIRED ELEMENT</li> <li>a -&gt; desired acceleration and deaceleration of leading joint [% from 0 - 100] OPTIONAL ELEMENT</li> <li>v -&gt; speed of leading joint (Joint that needs to travel the longest) [% from 0 - 100] OPTIONAL ELEMENT</li> <li>t -&gt; desired duration of the move [s] OPTIONAL ELEMENT</li> <li>func -&gt; can be \"poly\" or \"trap\" [no unit] OPTIONAL ELEMENT</li> <li>speed -&gt; can be speed or nothing [no unit] OPTIONAL ELEMENT</li> </ul> <p>Arguments need to be given in above defined order!</p> <p>If t is defined robot will finish its move in that defined time. t overrides a and v if they are given. Here default func is \"poly\". Even if it is not defined robot will use \"poly\". In case you want to use trapezoidal profile use func \"trap\". When using trapezoidal profile and t is defined speed profile will be 1/3 acceleration, 1/3 cruise speed, 1/3 deaceleration. Example:</p> <pre><code>MoveJoint(0,-90,180,0,0,180,t=4)\n</code></pre> <p>If both a and v are defined robot will try to move at those specified speeds. When a and v are defined robot can only use trapezoidal profiles and they are automatically selected you do not need to define func as \"trap\". Specified a and v are applied to LEADING joint, that is the joint that will need to travel the longest. Because of that a and v percenteges that will work for LEADING joint will not necesarry work for other joints. If they do not work control algorithm will select proper move profile indepentand on a and v values. values will then be selected by this rule needed and initial are not the same but path is really small use 1/3 acc, 1/3 cruise and 1/3 deac. Example:</p> <pre><code>MoveJoint(0,-90,180,0,0,180,v=50,a=50)\n</code></pre> <p>If only j1,j2,j3,j4,j5,j6 are given and no other variable joints algorithm       will use small conservative speed and acceleration. \"trap\" function will be used. Example:</p> <pre><code>MoveJoint(0,-90,180,0,0,180)\n</code></pre> <p>In case you define your last arguments as speed, the robot will only follow the speed curve of the generated trajectory. It will generate motion that is more silent and smooth but will miss its desired position.  Example: </p> <pre><code>MoveJoint(0,-90,180,0,0,180,speed)\n</code></pre> <p>Example commands and explanation:</p>"},{"location":"page4/#moveposexyzrxryrzv0a0t0funcspeed","title":"MovePose(x,y,z,Rx,Ry,Rz,v=0,a=0,t=0,func,speed)","text":"<p>Robot will move all its joints to the desired orientation tracking a specific velocity curve. Joints will stop at the same time at the desired positons. The path is linear in joint space, because of that actuator motion is easy to validate and predict but TRF/end-effector is hard to predict. Can track trapezoidal velocity profile or polynomial. User can set desired duration of the move or specific acceleration and velocity.  The move can be tracked based on speed curve alone or combination of commanded speed curve and position curve.</p> <ul> <li>x,y,z,Rx,Ry,Rz -&gt; desired robot pose. x,y,z are in [mm]; Rx,Ry,Rz are in [degrees] REQUIRED ELEMENT</li> <li>a -&gt; desired acceleration and deaceleration of leading joint [% from 0 - 100] OPTIONAL ELEMENT</li> <li>v -&gt; speed of leading joint (Joint that needs to travel the longest)[% from 0 - 100] OPTIONAL ELEMENT</li> <li>t -&gt; desired duration of the move [s] OPTIONAL ELEMENT</li> <li>func -&gt; can be \"poly\" or \"trap\" [no unit] OPTIONAL ELEMENT</li> <li>speed -&gt; can be speed or nothing [no unit] OPTIONAL ELEMENT</li> </ul> <p>Arguments need to be given in above defined order!</p> <p>Rules that apply to MoveJoint() are same for MovePose. Code is the same except that control algoritam will calculate joint angles using inverse kinemtics from needed robot pose. Because of that you might end up with robot joint configuration that is not same as one that you wanted.</p> <p>Example commands and explanation:</p>"},{"location":"page4/#speedjoint","title":"SpeedJoint()","text":""},{"location":"page4/#movecartxyzrxryrzt0funcspeed","title":"MoveCart(x,y,z,Rx,Ry,Rz,t=0,func,speed)","text":"<p>Robot will move all its joints to the desired orientation tracking a specific velocity curve. Joints will stop at the same time at the desired positons. The path is linear in tools / task    space, Actuator motion not necessarily smooth and harder to validate. Can track trapezoidal velocity profile or polynomial. With this mode robot cant pass singularities and is affected by them. Note that when robot gets close to singularity it will stop. Robot will try to exectute the trajectory even if it has singularity in it. User needs to make sure their robot can pass thru the singularity by properly designing the task and robotic cell.  User can set desired duration of the move with variable t. </p> <p>Arguments need to be given in above defined order!</p> <ul> <li>x,y,z,Rx,Ry,Rz -&gt; desired robot pose with respest to WRF. x,y,z are in [mm]; Rx,Ry,Rz are in [degrees] REQUIRED ELEMENT</li> <li>t -&gt; desired duration of the move [s] OPTIONAL ELEMENT</li> <li>func -&gt; can be \"poly\" or \"trap\" [no unit] OPTIONAL ELEMENT</li> <li>speed -&gt; can be speed or nothing [no unit] OPTIONAL ELEMENT</li> </ul> <p>Example commands and explanation:</p>"},{"location":"page4/#movecartreltrfxyzrxryrzt0funcspeed","title":"MoveCartRelTRF(x,y,z,Rx,Ry,Rz,t=0,func,speed)","text":"<p>Unlike MoveCart where pose is defined with respect to WRF in MoveCartRelTRF we are moving robot pose relative to current Tool reference frame. With this mode robot cant pass singularities and is affected by them. Note that when robot gets close to singularity it will stop. Robot will try to exectute the trajectory even if it has singularity in it. User needs to make sure their robot can pass thru the singularity by properly designing the task and robotic cell.</p> <ul> <li>x,y,z,Rx,Ry,Rz -&gt; pose arguments relative to TRF. x,y,z are in [mm]; Rx,Ry,Rz are in [degrees] REQUIRED ELEMENT</li> <li>t -&gt; desired duration of the move [s] OPTIONAL ELEMENT</li> <li>func -&gt; can be \"poly\" or \"trap\" [no unit] OPTIONAL ELEMENT</li> <li>speed -&gt; can be speed or nothing [no unit] OPTIONAL ELEMENT</li> </ul> <p>When rotating around x, y and z using Rx ,Ry, Rz it is recommended to make 2 succesive commands. Example:</p> <pre><code>MoveCartRelTRF(0, 0, 0, 0, 45, 0) \nMoveCartRelTRF(0, 0, 0, 0, 0, 45)\n</code></pre> <p>Example commands and explanation:</p>"},{"location":"page4/#delay","title":"Delay()","text":"<p>Delays the script by specific time in seconds [s]. Note that smallest delay can be equal to INTERVAL_S variable (loop time of the robot arm, usually 10ms) Example: </p> <pre><code>Delay(1.5) // Adds time delay of 1.5s\n</code></pre>"},{"location":"page4/#end","title":"End()","text":"<p>Intidates that script will stop exectuing at this moment Example:</p> <pre><code>End()\n</code></pre>"},{"location":"page4/#begin","title":"Begin()","text":"<p>Indicates that script will begin. Example:</p> <pre><code>Begin()\n</code></pre>"},{"location":"page4/#loop","title":"Loop()","text":"<p>When script reaches this command it will start executing from the beginning. Example:</p> <pre><code>Loop()\n</code></pre>"},{"location":"page4/#output","title":"Output()","text":"<p>Sets one of the 2 outputs HIGH or LOW.  Example:</p> <pre><code>Output(1, HIGH) // sets output 1 of PAROL6 control board to HIGH state\nOutput(2, LOW) // sets output 2 of PAROL6 control board to LOW state\n</code></pre>"},{"location":"page4/#gripper_cal","title":"Gripper_cal()","text":"<p>This command will calibrate and activate the gripper. After calling it place a delay in the code to let it execute. Example:</p> <pre><code>Gripper_cal()\nDelay(2)\n</code></pre>"},{"location":"page4/#gripperpositionspeedcurrent","title":"Gripper(position,speed,current)","text":"<p>Gripper allows you to control SSG48 gripper connected to your PAROL6 robot.</p> <ul> <li>Position sets the positon setpoint of the gripper; ranges from 0 - 255; 0 fully open 255 fully closed</li> <li>Speed sets the move speed of the gripper ranges from 0 to 255; 0 lowest speed 255 full speed</li> <li>Current sets the force the gripper will apply to the object ranges from 0 - 1300 [mA]; *Note values smaller than 150 will usually be to low to move the gripper</li> </ul> <p>be carefull when using large current values (over 700) paired with high speed setpoint they can case damage to you and objects that are being grasped</p> <p>When using gripper command after being called the program will move to the next command. So it is recommended to use Delay() after calling gripper command. Example: </p> <pre><code>Gripper(120,30,500) // Move the gripper to positon 120 with speed of 30 and with current setpoint of 500mA\nDelay(2)\n</code></pre>"},{"location":"page4/#example-codes","title":"Example codes","text":""},{"location":"page4/#simple-joint-space-move-code","title":"Simple Joint space move code","text":"<p>This code will perfrom small joint space movements in the loop.</p> <pre><code>Begin()\nDelay(1)\nMoveJoint(85.078,-111.195,143.513,-32.92,18.084,129.448,t=3)\nDelay(1)\nMoveJoint(66.129,-117.368,136.77,46.28,-29.588,149.293)\nDelay(1)\nLoop()\n</code></pre>"},{"location":"page4/#cartesian-trf-example-code","title":"Cartesian TRF example code","text":"<p>This code will move the robot in TRF space. First translation in x,y,z direction then rotation around x,y,z of TRF. *Note look at the simulator window to see how the robot follows the axes.</p> <pre><code>Begin()\nDelay(1)\nMoveJoint(90.0,-90.0,180.001,0.0,0.0,180.0,t=4)\nDelay(1)\nMoveCart(0.0,263.23,161.241,-90.0,0.0,-89.499)\nDelay(1)\nMoveCart(81.565,262.804,161.047,-90.135,-0.029,-89.578)\nDelay(1)\nMoveCart(81.649,194.981,160.077,-90.14,-0.043,-89.593)\nDelay(1)\nMoveCart(83.598,194.356,161.493,-91.155,1.306,-80.28)\nDelay(1)\nMoveCart(84.56,194.131,162.347,-48.387,1.261,-80.188)\nDelay(1)\nMoveCart(82.89,191.698,162.369,-40.587,26.026,-107.028)\nDelay(1)\nEnd()\n</code></pre>"},{"location":"page4/#cartesian-relative-trf","title":"Cartesian relative TRF","text":"<p>This code moves the gripper relative to the last position. In this example we move for -80 mm in x direction of TRF.</p> <pre><code>Begin()\nDelay(1)\nMoveJoint(90.0,-90.0,180.001,0.0,0.0,180.0,t=4)\nDelay(1)\nMoveCartRelTRF(-80,0,0,0,0,0)\nDelay(1)\nEnd()\n</code></pre>"},{"location":"page4/#ssg48-gripper-test-code","title":"SSG48 gripper test code","text":"<p>This code will calibrate the gripper and perfrom few open-close operations. After that robot will make small move in joint space and small move in TRF cart space. First we need to call Begin to start the program. After that we call Gripper_cal() to calibrated the gripper. After the gripper is calibrated we can start using it. *Note if there is gripper error you will have to manually clear it in the gripper tab of the GUI!</p> <pre><code>Begin()\nGripper_cal()\nDelay(3)\nGripper(100,60,600)\nDelay(2)\nGripper(200,60,600)\nDelay(2)\nMoveJoint(85.192,-104.451,158.769,-1.983,-46.491,179.899,t=6)\nDelay(1)\nMoveCart(4.317,103.384,192.319,-84.465,1.447,-143.154)\nGripper(100,60,600)\nDelay(2)\nEnd()\n</code></pre>"},{"location":"page4/#output-click-code","title":"OUTPUT click code","text":"<p>This code turns on and off OUTPUT1 of the robot arm. You can use this code example to control the pneumatic gripper.</p> <pre><code>Begin()\nOutput(1,HIGH)\nDelay(1)\nOutput(1,LOW)\nDelay(1)\nLoop()\n</code></pre>"},{"location":"page4_1/","title":"PAROL commander GUI","text":"<p>When you start PAROL6 commander software you will be met with 2 windows: </p> <ul> <li>Commander window</li> <li>Simulator window</li> </ul> <p> </p> <pre><code>    Fig - commander window\n</code></pre> <p> </p> <pre><code>    Fig - simulator window\n</code></pre> <p>Commander window is used to Jog robot, read logs, write programs, home the robot... Simulator window is used to show your robot in real time.</p> <p>Note</p> <p>Simulator only works if your robot is connected!</p> <p> </p> <pre><code>    Fig - Connect bar\n</code></pre> <p>At the bottom of commander software window you will see an entry bar and connect button. </p> <p>In the field next to the Connect button enter your serial com port. * Windows: enter COMx (x represents your com port number) * Linux: enter ttyACMx (x represents your com port number)</p> <p>Clear error has same function as enable button.</p> <p>Sim and real robot buttons have no function at the moment.</p> <p> </p> <pre><code>    Fig - cartesian jog\n</code></pre> <p>Cartesian jog is used to move robot in cartesian space. You can use  TRF frame or WRF frame. TRF is represented by axes on your end effctor while WRF is represented by axes on the robot base. </p> <p>Note</p> <p>When jogging in cartesian mode you WILL hit singularities. Go to general concepts tab on this webpage and read more about them! </p> <p> </p> <pre><code>    Fig - joint jog\n</code></pre> <p>Joint jog is used to jog indivitial motors. LEFT IS POSITIVE DIRECTION RIGHT IS NEGATIVE DIRECTION!</p> <p> </p> <pre><code>    Fig - program window\n</code></pre> <p>This window allows you to write robot scripts. Check the software tab to learn more about it!</p> <p> </p> <pre><code>    Fig - start stop tab\n</code></pre> <p>You can start the execution of your programs by pressing start. By pressing stop the program will stop. </p> <p> </p> <pre><code>    Fig - commands window\n</code></pre> <p>This window allows you to just select commands you want to use and click on them. They will appear in the program window. If using current positon/pose movement commands (MoveJoint, MovePose, SpeedJoint, MoveCart,MoveCartRelTRF, SpeedCart...) they will add current pose or joint position as arguments. Custom positon/pose will not add any values.</p> <p> </p> <pre><code>    Fig - Response log\n</code></pre> <p>In the response log you will see error logs and active commands.</p> <p> </p> <pre><code>    Fig - robot position\n</code></pre> <p>Here you can see the position of the robot joints and the position of end-effector in cartesian space. You can change the joint and cartesian space velocity with the slider. Home button will start homing your robot. Enable button will clear all errors and enable robot for operation. Disable will disable robot.</p> <p>All we talked about was located in Move menu. All other menus will stay the same only the JOG MENUS will be replaced with another window! </p> <p> </p> <pre><code>    Fig - IO tab\n</code></pre> <p>Here you can check the state of your inputs and set the desired state to your outputs</p> <p> </p> <pre><code>    Fig - Settings tab\n</code></pre> <p>Here you can change GUI from dark to light mode and change the scaling to fit</p> <p> </p> <pre><code>    Fig - Gripper tab\n</code></pre> <p>Here you control and configure your gripper. After homing the robot press calibrate gripper button.  Gripper will start to move and its status will change to calibrated. Press \"clear gripper error\".  Now you can command gripper to go to the specific position with specific speed and torque. </p> <p>Set the setpoints with the sliders and press \"Move GoTo\" Under gripper feedback you will see gripper current and position feedback. You will also see what is status of the gripper. If it is in motion, detected object...</p>"},{"location":"page5/","title":"Peripherals","text":"<p>PAROL6 control board has multiple ways to interact with outside world. Communication with high level code running on a PC is done with USB, but on top of that you can use other features like I/O or CAN to communicata.</p> <p> </p>"},{"location":"page5/#io-connections","title":"I/O connections","text":"<p>PAROL6 is equipped with 2 isolated inputs and 2 isolated outputs.</p>"},{"location":"page5/#isolated-power-supply","title":"Isolated power supply","text":"<p>It is standard to have isolated Inputs and Outputs to protect your device. To use isolated power supply follow the connections on image below. Connect minus of power supply  to any of GND_SEL pins and plus of power supply to any of HV_SEL pins.</p> <p>Note!</p> <p>Even tho Inputs and Outputs are now isolated from the robot, the ESTOP is still connected to the same power supply of the robot</p> <p> </p> <p>By using isolated power supply you are not limited to 24V. You can use 5V or 12V depending on your aplications.</p>"},{"location":"page5/#not-isolated-power-supply","title":"Not isolated power supply","text":"<p>By following the connections as shown on image below all inputs and outputs will be connected to power supply of the robot.</p> <p> </p>"},{"location":"page5/#examples-of-input-connections","title":"Examples of input connections","text":"<p>Inputs can be limit switches, push buttons, Sensors... For limit switch connect one end of the switch to HV_SEL and another one to IN1 or IN2.</p>"},{"location":"page5/#examples-of-output-connections","title":"Examples of output connections","text":"<p>Outputs can be releys, lamps, low power actuators... For releys connect one end to GND_SEL and another to OUT1 or OUT2.</p>"},{"location":"page5/#can-bus","title":"CAN bus","text":"<p>Still under developement</p> <p>Can bus will allow you to connect external grippers and additional axes.  There are 2 CAN buses. Note* CAN2 is not soldered by default!</p>"},{"location":"page5/#ssg48-gripper","title":"SSG48 Gripper","text":"<p>The gripper connects to the following connector on the PAROL6 robotic arm.   If building your own robot and gripper make sure you follow the wiring instructions. Failing to do that can destroy your gripper and control board. First test the PAROL6 robot and then attach the gripper. Trying to troubleshoot both at the same time will be hard.</p> <p> </p> <p>SSG48 Works by default with PAROL6 commander software and control board. There is no need to configure anything; it is plug and play experiance.</p> <p>If you want to build or buy one check the link below: https://source-robotics.com/products/compliant-gripper</p> <p>Change in main.cpp</p> <p>If using SSG48 gripper; In the main.cpp file change j5_homing_offset to be equal to 8035</p>"},{"location":"page5/#pneumatics","title":"Pneumatics","text":"<p>Recommended pressure</p> <p>Recommended pressure for PAROL6 and generally in industry is 6-8 bar. All examples conducted with pneumatics you see in our videos are done with pressures in that range.</p>"},{"location":"page5/#example-of-gripper-connection","title":"Example of gripper connection","text":"<p>The 2 tubes going into a gripper are tubes that exit the PAROL6 robotic arm at a forearm region.   Tubes going from the pneumatic valve need to be connected to the pneumatic connections in the base of the robot.   Orientation is imporatant. Switching the 2 tubes will make your gripper normally closed or normally open depending on the orientation. </p> <p> </p> <p>Connect valve wires to GND_SEL and OUTPUT1.</p>"},{"location":"page5/#vacuum-gripper","title":"Vacuum gripper","text":"<p>You will have to print vacuum gripper holder from the github folder. By default the gripper will spin freely; if you dont want that tie it up with a zip tie to the screw on the image.</p> <p> </p> <p>You will have to block one port of pneumatic valve. You can use a tube of fitting size and screw in a M3 screw with threadlocker on it.</p> <p> </p>"},{"location":"page5/#estop","title":"Estop","text":"<p>Connection is as follows:</p> <p> </p> <p>Estop needs to be connected for normal operation of the robot</p> <p>TIP</p> <p>If you dont have an ESTOP you can use any NC switch!</p> <p>TIP2</p> <p>On PAROL6 controller board there are connectors for 2 ESTOPS. They both share same GPIO on microcontroller. They both need to be NC contact. </p> <p>Estop needs to be NORMALLY CLOSED (NC) contact type. NO will not work. NC is beneficial in case your estop unplugs or gets its wires cut it will also register as a press of an estop, which is desirable behaviour.</p>"},{"location":"page6/","title":"Safety and handling","text":"<p>Warning</p> <p>Not following the procedures can cause damage to the robot and operator. Make sure you read them and FOLLOW THEM!</p> <p>PAROL6 needs special handling even tho it is lightweight desktop robot. Weighting only 5kg it still needs to be anhored to the surfaces. In case of power loss the robots joints will not hold themselfs and robot will start to fall down. That is the property of the relativly low reduction ratios in PAROL6. </p> <p>Addition of brakes</p> <p>Solution for that problem, like in industrial aplications is to use brakes. Addition of brakes is on TODO list for PAROL6.</p> <p> </p> <p>PAROL6 requires 3 connections for normal operation.</p> <ul> <li> <p>Power connection -&gt; Marked green on image</p> </li> <li> <p>USB connection -&gt; Marked blue on image</p> </li> <li> <p>ESTOP -&gt; Marked with yellow and pink squares (One lead of ESTOP to pink one to yellow)</p> </li> </ul>"},{"location":"page6/#code-upload","title":"Code upload","text":"<p>When uploading code to the PAROL6 controller board TURN OFF the 24V power supply of the robot. When uploading code to PAROL6 controller board it receives 3v3 from stlink device. This keeps the robot constantly ON and blocks the shutdown of the robot with a powerbutton located on the base.  After the code is uploaded disconnect the stlink, turn on the robot with power button located on the base and then run the PAROL6 commander software.</p>"},{"location":"page6/#usb","title":"USB","text":"<p>USB connection does not power the board!</p>"},{"location":"page6/#safe-shutdown","title":"Safe shutdown","text":"<p>Do not try to power off the robot when it is running!</p> <p>If robot start to behave unexpectedly USE ESTOP. If ESTOP is not functional power of the power supply. Reaching for the power button should be the last option.</p> <p>Because lack of brakes sudden loss of power will result in robot falling down. That may cause damage to the robot or the operator. Robot is powered on and off by pressing a button marked red on the image. When powering the robot on even when USB connection is not available it will energise the the motors. It will produce 6 clicking sounds and that is normal behaviour.</p> <p>Powering off the robot is also done by pressing button marked in RED. Before you power off the robot GRAB IT BY THE FOREARM and then press the button. This will ensure that robot does not fall down.</p>"},{"location":"page6/#anchoring-the-robot","title":"Anchoring the robot","text":"<p>Robot that is not anchored WILL fall over!</p> <p>There are 2 ways of anchoring the robot:</p> <ul> <li>Using the 6 holes in the base of the robot to attach it to the surface</li> <li>Using clamps to attach it to the edge of the table or work surface</li> </ul> <p> </p> <p>Base holes are spaced for easy mounting on 30x30 aluminum profiles</p> <p>Another option is to use \"connectors_4_alu_profiles.STL\" that can be found in the STL folder of PAROL6 github to create a base like shown in the image below. For that you will also need:</p> <ul> <li>T-nuts for 30x30 profile (M5)</li> <li>M5 x 12 mm screws</li> <li>18 - 20 mm M5 screw</li> </ul> <p> </p>"},{"location":"page6/#pinching-points","title":"Pinching points","text":"<p>Be careful when the robot is running. There are few pinching points that can hurt you and others.  Also make sure that additional wires or tubes are not in the pinching points!</p>"},{"location":"page6/#joint-limits","title":"Joint limits","text":"<p>Warning</p> <p>Never spin joint 5 more then one rotation</p> <p> </p> <p>The image above represents the range of J5.</p>"},{"location":"page6/#transport","title":"Transport","text":"<p>When moving the robot it is best to move joints 2 and 3 to the limit switches. After that grab the robot by the base and you can carry it around.</p> <p>When packing the robot it is recommended to put some kind of sponge or styrofoam under J3 limit switch. After that you can tape around forearm and upper arm links.</p>"},{"location":"page6/#estop","title":"ESTOP","text":"<p>Estop needs to be connected for normal operation of the robot</p> <p>TIP</p> <p>If you dont have an ESTOP you can use any NC switch!</p> <p>TIP2</p> <p>On PAROL6 controller board there are connectors for 2 ESTOPS. They both share same GPIO on microcontroller. They both need to be NC contact. </p> <p>Estop needs to be NORMALLY CLOSED (NC) contact type. NO will not work. NC is beneficial in case your estop unplugs or gets its wires cut it will also register as a press of an estop, which is desirable behaviour.</p>"},{"location":"page7/","title":"General concepts","text":"<p>The PAROL6 robotic arm serves as an exceptional tool for educators aiming to enhance their students' understanding of robotics and automation. Its innovative design and user-friendly features make it an ideal platform for various educational settings. In our commitment to fostering a deep understanding of robotics and empowering educators to enhance their curriculums, the PAROL6 documentation includes a dedicated \"Theory Corner.\" This section serves as a valuable resource for individuals seeking to delve into the theoretical foundations of robotics and educators striving to enrich their teaching materials.</p> <p>The Theory Corner is designed to provide comprehensive explanations of essential robotic concepts. Whether you're a newcomer to robotics or a seasoned enthusiast, this section offers insights into topics such as kinematics, dynamics, control systems, sensors, programming languages, and more. </p> <p>Note</p> <p>This is still work in progress and is being constantly updated!  </p>"},{"location":"page7/#want-to-know-more","title":"Want to know more?","text":"<p>Here is a list of great resources that you can use to learn more about robotics:</p> <ul> <li>https://robotacademy.net.au/</li> <li>https://automaticaddison.com/</li> <li>https://robogrok.com/</li> <li>https://github.com/mithi/robotics-coursework</li> <li>https://robotics-explained.com</li> <li>https://roboticseabass.com</li> <li>https://robohub.org</li> </ul>"},{"location":"page7/#basic-theory","title":"Basic theory","text":""},{"location":"page7/#joints-and-naming","title":"Joints and naming","text":"<p>Joint are numbered from bottom to the top of the arm. In case of PAROL6 it follows naming on the Figure 1.</p> <p> </p> <pre><code>                    Figure: Robot joint naming\n</code></pre>"},{"location":"page7/#rules-and-convenctions","title":"Rules and convenctions","text":""},{"location":"page7/#right-hand-rule-for-axes","title":"Right hand rule for axes","text":"<p>The right-hand rule is a convention used to define the orientation of coordinate systems in three-dimensional space. It provides a consistent way to determine the positive directions of the axes (x, y, and z) in relation to each other.</p> <p>Here's how the right-hand rule works when assigning coordinate systems:</p> <ul> <li> <p>Thumb: Align your right thumb along the positive direction of the first axis (usually the x-axis). This is the axis that typically points to the right.</p> </li> <li> <p>Index Finger: Extend your right index finger perpendicular to your thumb. This represents the positive direction of the second axis (usually the y-axis), which is often considered the \"up\" direction.</p> </li> <li> <p>Middle Finger: Orient your right middle finger so that it is also perpendicular to your thumb and index finger. The middle finger represents the positive direction of the third axis (usually the z-axis), forming a right-handed coordinate system.</p> </li> </ul> <p>With your hand in this configuration, the three fingers (thumb, index finger, and middle finger) define the positive directions of the x, y, and z axes, respectively. This right-hand rule establishes a consistent standard for defining coordinate systems in three-dimensional space.</p> <p>For rotation; orient your thumb in positive direction of axes you want to see positive rotation for. Your fingers now curl in the positive direction of rotation around that axis.</p>"},{"location":"page7/#concepts","title":"Concepts","text":""},{"location":"page7/#types-of-robots-and-number-of-joints","title":"Types of robots and number of joints","text":"<p>There are a lot of robot types in industry usually categorised by number of joints and how the joints are arranged. Some of the types of the robots are:</p> <pre><code>\u2022 Vertically articulated.\n\u2022 Cartesian.\n\u2022 Cylindrical.\n\u2022 Polar.\n\u2022 Selective compliance assembly robot arm (SCARA).\n\u2022 Delta\n</code></pre> <p>PAROL6 is vertically articulated robot. All conecepts here apply to any type of the robot but most of the examples will be for robots like PAROL6.</p>"},{"location":"page7/#spherical-wrist","title":"Spherical wrist","text":"<p>The first 3 axes are used to position the end effector in cartesian space while the last 3 joints are used to change the end effector orientation.  PAROL6 uses a popular configuration where the axes of rotation of the last 3 joints intersect. That configuration is called a spherical wrist and is one of the most common configurations you will see in industrial robots.  A spherical wrist allows for much easier and faster calculation of inverse kinematics.  You can see an example of a spherical wrist on the example of Faze4 robotic arm in the image below.</p> <p> </p> <pre><code>                    Figure: left robot with spherical wrist, right robot without spherical wrist\n</code></pre>"},{"location":"page7/#robot-pose","title":"Robot pose","text":"<p>In robotics, the term \"pose\" refers to the position and orientation of a robot in its environment. It provides a complete description of where the robot is located and how it is oriented relative to a specific coordinate system or frame of reference. The pose typically includes:</p> <ul> <li> <p>Position: This specifies the location of the robot in the environment. In a 2D space, this is often represented by a pair of coordinates (x, y), while in a 3D space, it includes three coordinates (x, y, z). These coordinates are usually given with respect to a fixed reference point.</p> </li> <li> <p>Orientation: This specifies the orientation or rotation of the robot in space. In 2D, it can be represented as an angle (\u03b8) relative to a reference direction (e.g., the x-axis). In 3D, it often uses representations like Euler angles, roll-pitch-yaw angles, or rotation matrices to describe the orientation.</p> </li> </ul> <p>The combination of position and orientation fully defines the pose of the robot at a specific moment in time.</p>"},{"location":"page7/#orientation","title":"Orientation","text":"<p>6 axes means it has 6 joints in our case 6 rotational joints. Joints are connected with links.  The advantage of robot arms of this type is that they can get to the same position in space with different orientations.  Both pictures show the arm at position x=0.3m, y=0.3m, and z=0.2m but as you can see orientations are different. Robot's pose in 3D space is described by the position and orientation ( rotation) of the robot's end effector in 3D space.</p> <p> </p> <pre><code>                    Figure: Same position in space different orientation\n</code></pre>"},{"location":"page7/#frames","title":"Frames","text":"<p>Coordinate frames or axes are often included at each joint to show the orientation and position of each joint relative to a common reference frame. These frames help in defining the transformations between different segments of the arm.</p>"},{"location":"page7/#wrf","title":"WRF","text":"<p>World reference frame This is a static frame that is fixed in real world. It is usually located in the base of the robot.  For PAROL6 it is located in the base. See figure xx. Coordinate frame represents world frame.</p>"},{"location":"page7/#trf","title":"TRF","text":"<p>TRF - Tool reference frame Reference frame that is associated to robots end-effector. This frame changes depending on what end effector you use. </p> <p> </p> <pre><code>                    Figure: Robot with TRF\n</code></pre>"},{"location":"page7/#links","title":"Links","text":"<p>The links represent the rigid segments or sections of the robotic arm. These could be actual physical components or conceptual representations. Links are typically depicted as straight lines connecting joints. Links can for example be shoulder, wrist, forearm...</p>"},{"location":"page7/#joints","title":"Joints","text":"<p>The joints represent the articulation points where motion occurs. These can include revolute joints (rotational) and prismatic joints (linear). Joints are often shown as small circles or symbols, with appropriate labels indicating the type of joint and possibly its degree of freedom.</p>"},{"location":"page7/#kinematic-diagram","title":"Kinematic diagram","text":"<p>A kinematic diagram of a robotic arm is a simplified graphical representation that illustrates the arrangement of links and joints in the robotic arm. It serves to convey the essential geometric and kinematic relationships between the various components of the arm without necessarily capturing all the physical details.</p> <p> </p>"},{"location":"page7/#denavit-hartenberg-parameters","title":"Denavit-Hartenberg parameters","text":"<p>Denavit-Hartenberg parameters are a set of standardized parameters used to describe the geometry and kinematics of robotic arms and mechanisms. They provide a systematic way to represent the transformation between consecutive coordinate frames along a robot's kinematic chain. These parameters were introduced by Jacques Denavit and Richard S. Hartenberg in the 1950s and have become a fundamental tool in robotics.</p> <p>The Denavit-Hartenberg parameters consist of four values associated with each joint of a robotic arm:</p> <ul> <li>Link length = distance Zi-1 from Oi-1 to the intersection with Xi.</li> <li>Link offset = Distance from Oi-1 and Oi measured along Xi</li> <li>\u03b8 THETA = Rotation around Zi-1 to get Xi-1 to match Xi</li> <li>\u03b1 ALPHA = Rotation around Xi to get Zi-1 to match Zi (We are rotating frame Oi-1 around Xi)</li> </ul> <p>These parameters are defined for each pair of consecutive joints in the robot's kinematic chain. By applying a sequence of transformations using these parameters, you can calculate the overall transformation matrix that represents the position and orientation of each link relative to a reference frame.</p> <p>The Denavit-Hartenberg parameters provide a consistent and concise way to model and analyze the kinematics of complex robotic systems, making them a widely used approach in robot design, control, and simulation.</p> <p>Great guides:</p> <ul> <li>Link</li> <li>Link</li> </ul> <p> </p>"},{"location":"page7/#forward-kinematics","title":"Forward kinematics","text":"<p>Forward kinematics is a fundamental concept in robotics that involves determining the position and orientation of a robot's end effector (such as a gripper or tool) based on the known joint angles and link parameters. In simpler terms, it's the process of calculating the robot's pose (position and orientation) in space given the joint configurations.</p> <p>The forward kinematics problem is about understanding how the robot's various joints and links combine to determine the position and orientation of the end effector. It's like tracing the path of the robot's movements to find out where its hand or tool ends up.</p>"},{"location":"page7/#inverse-kinematics","title":"Inverse kinematics","text":"<p>Inverse kinematics is a fundamental concept in robotics that involves determining the joint angles or parameters of a robotic mechanism in order to achieve a desired end-effector position and orientation. In simpler terms, it's the process of calculating the joint configurations that will result in a specific pose (position and orientation) of the robot's end-effector (e.g., its hand or tool).</p> <p>In a robotic arm, for example, the forward kinematics process involves calculating the position and orientation of the end-effector based on the given joint angles. Inverse kinematics, on the other hand, works the opposite way: given a desired position and orientation for the end-effector, it calculates the joint angles that will achieve that particular pose.</p> <p>Inverse kinematics can be quite complex, especially for robots with multiple joints and degrees of freedom. Solving inverse kinematics involves finding solutions to sets of nonlinear equations that relate the joint variables to the desired end-effector pose. Depending on the robot's geometry and the specific task at hand, there may be multiple solutions, a unique solution, or even no solution.</p> <p>Inverse kinematics is crucial for tasks such as trajectory planning, motion control, and object manipulation, as it allows the robot to determine how to move its joints to achieve a specific goal in its operational environment. It's used in applications ranging from industrial robotics and automation to animation and simulation.</p>"},{"location":"page7/#singularity","title":"Singularity","text":"<p>When a robot navigates through Cartesian space, the reference frame transitions from individual joints to the end effector. The robot employs various joint movements to achieve the desired Cartesian motion for the end effector. To optimize joint movements, the robot calculates the necessary displacement and direction for each joint. This method generally works efficiently for most arm configurations. However, challenges arise at singularities, which occur when joints reach their limits or when two or more joints align collinearly.</p> <p>At these joint alignments, certain movements within Cartesian space become unattainable, leading to exceedingly high joint velocities. The mathematical equations governing the robot's motion approach singularity when divided by  small values. The actual singularity manifests when one of these equations is divided by zero, signifying the impossibility of the movement.</p> <p>Singularity point represent critical zones where the robot's kinematic equations encounter mathematical limitations due to specific joint configurations, resulting in movement impossibilities or erratic behavior.</p> <p>Video demonstration of singularities</p> <p>If you plan to program the robot to perform some tasks you will inevitably have to deal with singularities. These unique configurations can significantly obstruct the Cartesian movements of your robot's end-effector. It's important to understand how to navigate around robot singularities by strategically designing your robot cell.</p> <p>Because singularities are common in 6 axes robotic arms, you must learn how to identify and avoid them. </p> <p>Now that you know what are singularities and how to recognise them, how do we avoid them? This is a hard problem and usually requires a lot of trial and error. It can be only avoided by properly designing your robotic cell or task. If your robot is mounted to the cell and it keeps hitting the singularities you can do few things: * Change the adapter plate of your gripper/end-effector to be at a different angle. * Relocate the robot around the robotic cell * try another robot configuration/pose</p> <p>Certain robot manufacturers provide singularity avoidance features allowing the robot's end-effector to make slight deviations from the intended Cartesian trajectory to circumvent singularities. These options prove highly beneficial when absolute adherence to the trajectory isn't crucial. For instance, in scenarios where the robot's task involves movement away from or towards a target rather than precision tasks like gluing or assembly.</p> <p>These deviations enable seamless and smoother end-effector motion, ensuring continuity in movement without interruptions caused by singularities. By allowing slight deviations, the robot can navigate around singularities, maintaining a more stable and continuous trajectory while performing tasks that do not demand pinpoint accuracy.</p> <p>In contrast, PAROL6 robotic arm will try to keep the desired Cartesian trajectory although that might mean that the end-effector will stop when near singularity. Feature to try to avoid the singularity by small deviations is not implemented.</p>"},{"location":"page7/#workspace","title":"Workspace","text":"<p>Workspace is the total volume or area that a robot's end effector (e.g., gripper or tool) can reach. It depends on the robot\u2019s joint configuration, link lengths, and range of motion. Two common types: - Reachable workspace \u2014 all points the robot can physically touch - Dexterous workspace \u2014 all points the robot can reach with any required orientation A well-designed workspace ensures the robot can perform all intended tasks without collisions or overextension.</p>"},{"location":"page7/#reach","title":"Reach","text":"<p>Reach is the maximum straight-line distance from the robot\u2019s base to its end effector. It is typically measured when all joints are extended in a straight line. Longer reach allows a robot to interact with objects farther away, but may reduce stiffness and precision. Designers must balance reach with payload capacity and accuracy.</p>"},{"location":"page7/#velocity-control","title":"Velocity Control","text":"<p>Velocity control regulates how fast a robot joint or end effector moves. In this mode, the control system receives a desired speed as input and adjusts actuator power to maintain that speed. Uses: - Continuous motion applications (e.g., conveyor tracking) - Coordinated joint movement for smooth paths Velocity control often requires feedback (closed loop) for accuracy under varying loads.</p>"},{"location":"page7/#position-control","title":"Position Control","text":"<p>Position control moves a joint or end effector to a specific target location and holds it there. The controller constantly compares the current position (from sensors) to the target and corrects any deviation. Advantages: - High precision - Ideal for pick-and-place operations Example: A robotic arm moving to a defined point in 3D space to assemble a part.</p>"},{"location":"page7/#torque-control","title":"Torque Control","text":"<p>Torque control directly regulates the amount of rotational force applied by a joint\u2019s actuator. It allows the robot to apply a controlled force without focusing on a specific position or velocity. Applications: - Collaborative robots that must be safe around humans - Force-sensitive assembly tasks - Compliant motion for delicate operations Often used in advanced robotics where interaction with the environment requires adaptability.</p>"},{"location":"page7/#blends","title":"Blends","text":"<p>Blends (also called \"motion blending\" or \"path smoothing\") allow a robot to transition between motion commands without stopping at each intermediate point. Instead of sharp stops, the robot smoothly curves through waypoints, maintaining continuous motion. Benefits: - Reduced cycle time - Less mechanical wear - Smoother trajectories for delicate payloads</p>"},{"location":"page7/#trajectory","title":"Trajectory","text":"<p>A trajectory is the planned path that a robot\u2019s joints or end effector will follow over time, including position, velocity, and acceleration profiles. Trajectories ensure smooth, predictable movement while respecting mechanical limits. Types of trajectories: - Linear \u2014 straight lines in Cartesian space - Joint space \u2014 movement planned in terms of joint angles - Spline-based \u2014 smooth curves between waypoints Good trajectory planning improves efficiency, precision, and safety.</p>"},{"location":"page7/#optimal-path-placement","title":"Optimal path placement","text":"<p>Optimal path placement leads to faster cycle times and larger paths optimal choice of configuration leaed to larger workspace design cell layout correctly a lot of trial and error.</p>"},{"location":"page7/#trapezoidal-velocity-profile","title":"Trapezoidal velocity profile","text":""},{"location":"page7/#polynomial-velocity-profile","title":"Polynomial velocity profile","text":"<p>A quintic (5th order) polynomial is used with default zero boundary conditions for velocity and acceleration.  Zero boundary conditions mean that  typically means that you assume  that the velocity and acceleration are zero at the endpoints of the interval being interpolated.  This assumption is often used when constructing interpolating polynomials for motion or  physical systems where you want to ensure that the motion starts and ends from rest (zero velocity and acceleration).</p> <p> </p>"},{"location":"page7/#witness-marks","title":"Witness marks","text":"<p>In the context of robot arms, \"witness marks\" typically refer to marks or indicators that are used to verify or witness the alignment, position, or movement of components or parts within the robotic system. These marks can serve various purposes in robot arms and automation; but are usually used to master the robot.</p> <p>Witness marks can be used during the calibration process to ensure that different components are properly aligned or positioned as per the specified configuration.</p> <p>Parol6, Faze4, and CM6 robotic arms also have witness marks. These marks are indicated by holes in the mechanical parts, allowing the parts to be aligned by inserting a pin through those holes.</p> <p> </p> <pre><code>                    Figure: Witness marks of PAROL6 robot\n</code></pre>"},{"location":"page7/#robot-mastering","title":"Robot mastering","text":"<p>Mastering the robotic arm is the process of bringing your robots joints to the witness mark of that joint and recording the position that robot is at that point.</p> <p>When at the position of the witness mark robots position is know because of our knowledge of robots kinematics and CAD. it basically assigns robots encoder ticks / stepper ticks to the know joint angle</p> <p>Lets take an example of J1 of our PAROL6 robotic arm</p> <p> </p> <pre><code>                    Figure: Standby position of PAROL6 robotic arm\n</code></pre> <p>At this exact position our robots joint is at 0 degrees. If everything was perfect you would place a pin at the witness marks and it would fit with no problems. </p>"},{"location":"page7/#homing","title":"Homing","text":"<p>Homing is a process where a robot joint finds a known position in its rotation space, typically by hitting a limit switch or sensor.</p> <p>The process for PAROL6 and FAZE4 robots is the same as that for 3D printers. After powering up, the robot doesn't know its position and needs to be homed. By hitting a limit switch, we determine the robot joint's position based on our knowledge of the limit switch's location, which we have from the CAD model. For example, when we hit a limit switch on Joint 1, we know that we need xxx steps to reach a witness mark or Joint 1's 0-degree position.</p> <p>Now that we know our position after homing and the number of steps required from the limit switch to the witness mark, you might think we're done, right? Well, not quite. To be really precise, after hitting the limit switch, you should observe how many steps it actually takes from the limit switch to the witness mark. Each PAROL6 build may have slight differences due to various printers, tolerance variations, and parts.</p> <p>The Parol6 control board comes preloaded with generic parameters that will work for anyone building the robot. However, if you want to fine-tune your robot, you now have the option to do so.</p> <pre><code>By default PAROL6 homes in these steps:\n* Joint 1,2 and 3 move to the limit switch at the same time\n* Once all are pressed they move away from them and press again.\n* Now joints 1,2 and 3 move to standby position\n* Now joint 4 homes\n* After joint 4 is homed it moves to its standby position\n* Now Joint6 homes\n* After it homes it goes to positon to home joint 5\n* After joint5 homes joints 5 and 6 move to the standby position\n</code></pre> <p>Homing needs to look like shown in this video!</p>"},{"location":"page7/#backlash","title":"Backlash","text":"<p>Backlash is the small amount of play or lost motion between mechanical components, usually caused by gaps between gear teeth or flexible couplings. In robotic arms, backlash can lead to positioning errors because the actuator's motion does not immediately translate into movement of the end effector. Minimizing backlash is important for precision \u2014 it can be reduced by using preloaded gears, belts, or software compensation.</p>"},{"location":"page7/#actuators","title":"Actuators","text":"<p>Actuators are the components that convert electrical signals into mechanical motion. In robotics, they are responsible for moving joints, rotating parts, or gripping objects. Common types of actuators include: - Servo motors \u2014 precise control of position and speed - Stepper motors \u2014 open-loop positioning with discrete steps - DC/BLDC motors \u2014 continuous rotation, speed control - Pneumatic/hydraulic actuators \u2014 high force applications Choosing the right actuator depends on speed, torque, precision, and cost requirements.</p>"},{"location":"page7/#open-loop-control","title":"Open Loop Control","text":"<p>Open loop control is a control method where the system sends commands to actuators without feedback from sensors. It assumes that the actuator performs exactly as commanded. Advantages: - Simple and low cost - No need for position or speed sensors Disadvantages: - Inaccuracy due to missed steps, load changes, or mechanical wear - No automatic error correction Example: Driving a stepper motor without an encoder.</p>"},{"location":"page7/#closed-loop-control","title":"Closed Loop Control","text":"<p>Closed loop control uses feedback from sensors (like encoders) to compare the actual output with the desired target and correct any errors. Advantages: - High accuracy and repeatability - Ability to detect and correct errors - Stable operation under varying loads Disadvantages: - More complex hardware and software - Higher cost due to sensors and controllers Example: A servo motor system that adjusts power to maintain a precise position.</p>"},{"location":"page7/#stepper-motors","title":"Stepper Motors","text":"<p>Stepper motors are electromechanical devices that move in discrete steps. Each step corresponds to a fixed rotation angle, allowing precise control of position without needing feedback (in open loop mode). Pros: - Precise positioning - Simple control - No feedback required for basic applications Cons: - Can lose steps under high load - Lower efficiency compared to DC motors Commonly used in 3D printers, CNC machines, and robotic arms for low-to-medium speed motion.</p>"},{"location":"page7/#encoders","title":"Encoders","text":"<p>Encoders are sensors that provide feedback about position, rotation, or speed. They can be: - Incremental encoders \u2014 measure relative movement from a starting point - Absolute encoders \u2014 provide exact position within a full rotation Encoders are essential in closed loop control systems, ensuring that actuators move precisely to their target positions. They help improve accuracy, detect faults, and compensate for mechanical errors such as backlash.</p>"}]}